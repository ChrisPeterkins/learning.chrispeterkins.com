// WebAssembly compiler utilities for working with WAT and binary modules

export class WasmCompiler {
  // Hand-compiled WebAssembly modules in hex format
  static readonly modules = {
    // Fibonacci, isPrime, factorial, matrixMultiply functions
    algorithms: new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, // Magic number and version
      // Type section
      0x01, 0x07, 0x01, 0x60, 0x01, 0x7f, 0x01, 0x7f, // Function type: (i32) -> i32
      // Function section
      0x03, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, // 4 functions of type 0
      // Memory section
      0x05, 0x03, 0x01, 0x00, 0x01, // 1 page minimum
      // Export section
      0x07, 0x2f, 0x05,
      0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, // "memory"
      0x09, 0x66, 0x69, 0x62, 0x6f, 0x6e, 0x61, 0x63, 0x63, 0x69, 0x03, 0x00, // "fibonacci"
      0x07, 0x69, 0x73, 0x50, 0x72, 0x69, 0x6d, 0x65, 0x03, 0x01, // "isPrime"
      0x09, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x69, 0x61, 0x6c, 0x03, 0x02, // "factorial"  
      0x0e, 0x6d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x79, 0x03, 0x03, // "matrixMultiply"
      // Code section
      0x0a, 0x53, 0x04,
      // Fibonacci function
      0x14, 0x00, 0x20, 0x00, 0x41, 0x01, 0x4c, 0x04, 0x7f, 0x20, 0x00, 0x05,
      0x20, 0x00, 0x41, 0x01, 0x6b, 0x10, 0x00, 0x20, 0x00, 0x41, 0x02, 0x6b,
      0x10, 0x00, 0x6a, 0x0b, 0x0b,
      // isPrime function (simplified)
      0x0f, 0x00, 0x20, 0x00, 0x41, 0x02, 0x48, 0x04, 0x7f, 0x41, 0x00, 0x05,
      0x20, 0x00, 0x41, 0x02, 0x70, 0x45, 0x0b, 0x0b,
      // factorial function (simplified)
      0x12, 0x01, 0x01, 0x7f, 0x41, 0x01, 0x21, 0x01, 0x03, 0x40, 0x20, 0x00,
      0x45, 0x04, 0x40, 0x05, 0x20, 0x01, 0x20, 0x00, 0x6c, 0x21, 0x01, 0x20,
      0x00, 0x41, 0x01, 0x6b, 0x21, 0x00, 0x0c, 0x01, 0x0b, 0x0b, 0x20, 0x01, 0x0b,
      // matrixMultiply function (simplified)
      0x0a, 0x00, 0x20, 0x00, 0x20, 0x00, 0x6c, 0x20, 0x00, 0x6c, 0x0b
    ]),

    // Image processing functions
    imageProcessing: new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
      // Type section
      0x01, 0x0b, 0x02, 0x60, 0x02, 0x7f, 0x7f, 0x00, 0x60, 0x01, 0x7f, 0x01, 0x7f,
      // Function section  
      0x03, 0x04, 0x03, 0x00, 0x01, 0x01,
      // Memory section
      0x05, 0x04, 0x01, 0x01, 0x01, 0x10,
      // Export section
      0x07, 0x2a, 0x04,
      0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00,
      0x09, 0x67, 0x72, 0x61, 0x79, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x03, 0x00,
      0x04, 0x62, 0x6c, 0x75, 0x72, 0x03, 0x01,
      0x06, 0x69, 0x6e, 0x76, 0x65, 0x72, 0x74, 0x03, 0x02,
      // Code section
      0x0a, 0x1c, 0x03,
      // grayscale function
      0x0a, 0x00, 0x20, 0x00, 0x20, 0x01, 0x36, 0x02, 0x00, 0x0b,
      // blur function  
      0x06, 0x00, 0x20, 0x00, 0x41, 0x02, 0x74, 0x0b,
      // invert function
      0x08, 0x00, 0x41, 0xff, 0x01, 0x20, 0x00, 0x6b, 0x0b
    ]),

    // SIMD operations
    simd: new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
      // Type section
      0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x00,
      // Function section
      0x03, 0x03, 0x02, 0x00, 0x00,
      // Memory section
      0x05, 0x04, 0x01, 0x01, 0x01, 0x10,
      // Export section
      0x07, 0x1a, 0x03,
      0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00,
      0x07, 0x76, 0x65, 0x63, 0x41, 0x64, 0x64, 0x03, 0x00,
      0x07, 0x76, 0x65, 0x63, 0x4d, 0x75, 0x6c, 0x03, 0x01,
      // Code section
      0x0a, 0x0f, 0x02,
      // vecAdd function
      0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b,
      // vecMul function
      0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6c, 0x0b
    ])
  };

  static async compile(moduleKey: keyof typeof WasmCompiler.modules): Promise<WebAssembly.Instance> {
    const bytes = this.modules[moduleKey];
    const module = await WebAssembly.compile(bytes.buffer);
    const instance = await WebAssembly.instantiate(module, {
      env: {
        memory: new WebAssembly.Memory({ initial: 1, maximum: 16 }),
      }
    });
    return instance;
  }

  static async instantiate(moduleKey: keyof typeof WasmCompiler.modules): Promise<{
    instance: WebAssembly.Instance;
    module: WebAssembly.Module;
  }> {
    const bytes = this.modules[moduleKey];
    const result = await WebAssembly.instantiate(bytes.buffer, {
      env: {
        memory: new WebAssembly.Memory({ initial: 1, maximum: 16 }),
      }
    });
    return result;
  }
}

// JavaScript implementations for comparison
export const jsImplementations = {
  fibonacci(n: number): number {
    if (n <= 1) return n;
    return this.fibonacci(n - 1) + this.fibonacci(n - 2);
  },

  isPrime(n: number): boolean {
    if (n <= 1) return false;
    if (n === 2) return true;
    if (n % 2 === 0) return false;
    
    for (let i = 3; i * i <= n; i += 2) {
      if (n % i === 0) return false;
    }
    return true;
  },

  factorial(n: number): number {
    let result = 1;
    for (let i = 2; i <= n; i++) {
      result *= i;
    }
    return result;
  },

  matrixMultiply(size: number): number {
    let sum = 0;
    for (let i = 0; i < size; i++) {
      for (let j = 0; j < size; j++) {
        for (let k = 0; k < size; k++) {
          sum += 2; // Simplified calculation
        }
      }
    }
    return sum;
  },

  grayscale(pixels: Uint8ClampedArray): Uint8ClampedArray {
    const result = new Uint8ClampedArray(pixels.length);
    for (let i = 0; i < pixels.length; i += 4) {
      const gray = (pixels[i] * 0.299 + pixels[i + 1] * 0.587 + pixels[i + 2] * 0.114) | 0;
      result[i] = result[i + 1] = result[i + 2] = gray;
      result[i + 3] = pixels[i + 3];
    }
    return result;
  },

  invert(pixels: Uint8ClampedArray): Uint8ClampedArray {
    const result = new Uint8ClampedArray(pixels.length);
    for (let i = 0; i < pixels.length; i += 4) {
      result[i] = 255 - pixels[i];
      result[i + 1] = 255 - pixels[i + 1];
      result[i + 2] = 255 - pixels[i + 2];
      result[i + 3] = pixels[i + 3];
    }
    return result;
  }
};